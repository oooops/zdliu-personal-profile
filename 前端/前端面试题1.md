# 前端面试题
 
js模拟call apply
```js
Function.prototype.Call=function(context) {
  var context=context||window;
  context.fn=this
  var args=[];
  for(var i=1,len=arguments.length;i<len;i++){
    args.push('arguments['+i+']')
  }
  var result=eval('context.fn('+args+')')
    delete  context.fn
    return result
}

Function.prototype.Apply=function(context,arr) {
  var context=context||window;
  context.fn=this;
  
  var result;
  if(!arr){
    result=context.fn();
  }else{
    var args=[]
    for(var i=0,len=arr.length;i<len;i++){
      args.push('arr['+i+']')
    }
    result=eval('context.fn('+args+')')
  }
   delete context.fn;
  return result

}
```

模拟bind
```js
Function.prototype.Bind=function(context) {
  var $this=this // 保存原函数
  return function() { // 返回一个新函数
    return $this.apply(context,arguments) //执行新函数时，将传入的上下文context作为新函数的this
  }
  
}
//bind的应用场景
// 实现对象继承、事件处理、时间间隔函数、借用Array的原生方法
```

js改变this指向的三种方式: apply、call、bind

js 数组去重 
* 双层循环
* indexOf
* filter
* Object key
```js
function unique(array){
  var obj={};
  return array.filter(function (item,index,array){
    return obj.hasOwnProperty(typeof item +item)?false:(obj[typeof item+item]=true)
  })
}
```
* es6 Array.from(new Set([]))


Http协议： url ，请求行、请求头，请求正文、状态行、响应头、响应正文
浏览器缓存机制流程： 过期策略 --> 协商策略 --> 存储策略

浏览器渲染机制： DOM CSSOM Rendering tree layout painting

css布局 BFC,IFC,GFC,FFC

函数柯里化： 意思是将多参数的函数转换成单参数的形式

数组二维变一维
```js
const multiDimensionalArray = [ [, ], [, ], [, ] ];  
const flattenedArray = [].concat(...multiDimensionalArray);  

// 不用es6，如果只对二维处理
Array.prototype.concat.apply([], multiDimensionalArray)

```



Object.create() 和 new 的区别
* Object.create创建对象是创建一个拥有指定原型和若干个指定属性的对象，也就是说可以任意指定原型，甚至是null, 
* new Object（）只是创建了一个以Object.prototype为原型的对象


js深拷贝和浅拷贝


js继承
* 原型链继承
* 构造继承
* 实例继承
* 拷贝继承
* 组合继承
* 寄生组合继承

判断数据类型的方法 typeof Object.prototype.toString() ` [Object,Class]`
  
函数执行的步骤
* 1、函数被创建，保存作用域到内部属性`[[scope]]`
* 2、创建函数执行上下文，并函数执行上下文被压入执行上下文栈
* 3、函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链
* 4、第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明
* 5、第三步：将活动对象压入 checkscope 作用域链顶端
* 6、准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值
* 7、函数执行完毕，函数上下文从执行上下文栈中弹出

    
执行上下文的三个重要属性
* 变量对象
* this
* 作用域链

  

  

  

  













